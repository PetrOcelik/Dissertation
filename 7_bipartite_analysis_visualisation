library(bipartite); library(statnet); library(data.table); library(network)

#----------data----------

setwd("...data/live_data/live_1/twomode_data")
list1 <- list.files(pattern="twomode_matrix.csv")
list1 <- list1[order(nchar(list1), list1)]
n <- length(list1)
cam <- as.data.frame(read.csv(list1[[n]], header=T)) #codes by actors matrix (cam)
rownames(cam) <- cam$X
cam$X <- NULL

path <- ("...data/live_data/live_1/working_data/reduced")

data <- function(path) { 
  files <- dir(path, pattern ="reduced.csv", full.names = TRUE)
  tables <- lapply(files, read.csv)
  do.call(rbind, tables)
}
files <- dir(path, pattern ="reduced.csv", full.names = TRUE) #saving number of files

data <- data("...data/live_data/live_1/working_data/reduced")

#----------data processing----------

# attribute data

l.data <- data.frame(data$codename, data$length)
length <- aggregate(.~data.codename, l.data, sum) #gives sum of length values for each code

# code frequencies data

counts <- table(data[,2]) #observations (counts) of the codes in the data
codes <- levels(data[,2]) #code labels
d <- as.data.frame(data.table(codes, counts, by=codes)) #codes' frequencies
d$V2 <- as.integer(d$V2)
d <- d[,-3]
d <- d[order(d[,2]),]
tot <- sum(d[,2]) #total number of code counts
dp <- round(((d[,2]/tot)*100),2) #share of respective codes counts on the total count

# frame affiliations are based on the results of exploratory and interpretative analysis
# this part of the script was added later

frames <- c("risk", "risk", "risk", "responsibility", "risk", "risk", "risk", "risk", "responsibility", "risk",
           "risk", "risk", "risk", "responsibility",  "risk", "risk", "responsibility", "risk", "responsibility", 
           "dysfunctional_state", "risk", "responsibility", "responsibility", "responsibility", "dysfunctional_state", "risk", 
           "risk", "risk", "risk", "risk", "responsibility", "dysfunctional_state", "risk", "dysfunctional_state", 
           "responsibility", "responsibility", "responsibility", "dysfunctional_state")

d <- cbind(d,dp, frames) #adding frame affiliations
dnames <- c("codes", "count", "pct.", "frames")
colnames(d) <- dnames
d #resulting table

code.freq <- d[,c(1:3)] #codes' absolute and relative frequencies
setwd("...data/live_data/live_1/analysis_data/frequency/codes")
write.csv(code.freq, "n_47_12_live_1_code_frequency.csv", row.names=F)

nframes <- table(d[,4])
lframes <- levels(d[,4])
f <- as.data.frame(data.table(lframes, nframes, by=lframes))
f <- f[,c(1,2)]
colnames(f) <- c("frames", "codes")
f #number of codes (not their counts) affiliated to frames

# codes counts and shares for respective frames
t.risk <- d$frames=="risk"
d <- cbind(d, t.risk)
t.resp <- d$frames=="responsibility"
d <- cbind(d, t.resp)
t.dys <- d$frames=="dysfunctional_state"
d <- cbind(d, t.dys)
d

risk <- d[t.risk==T,]
resp <- d[d$t.resp==T,]
dys <- d[d$t.dys==T,]
risk <- risk[,-c(4,5,6,7)] 
resp <- resp[,-c(4,5,6,7)] 
dys <- dys[,-c(4,5,6,7)] 
risk #risk frame
resp #responsibility frame
dys #dysfunctional state frame

sum(risk[,2]) #code counts in risk frame
sum(resp[,2]) #code counts in responsibility frame
sum(dys[,2]) #code counts in dysfunctional state

round(((sum(risk[,2])/sum(d[,2]))*100), 0) #% share of risk frame
round(((sum(resp[,2])/sum(d[,2]))*100), 0) #% share of responsibility frame
round(((sum(dys[,2])/sum(d[,2]))*100), 0) #% share of dysfunctional state frame

twenty <- d$count >= 20 #saves codes with frequency 20 or more
dat <- d[twenty,]
dat

# histogram of codes with 20 and more observations
barplot(dat$count, names.arg=dat[,1], cex.names=0.75, cex.axis=0.75, col="lightgreen", ylim=c(0,50),
        main="codes with 20 and more observations", cex.main=1)

# relational data

cam <- as.matrix(cam) #incidence (codes by actors) matrix

# one-mode projections
coocc.data <- as.one.mode(cam, project="higher", weighted=TRUE) #codes cooccurence matrix (code by code)
over.data <- as.one.mode(cam, project="lower", weighted=TRUE) #actors overlap matrix (actor by actor)

# calculating treshold for edges (dropping weak edges)

# code by code matrix
r.sum1 <- rowMeans(coocc.data, na.rm = FALSE, dims = 1) #saving row means (i.e. average edge weights for respective concepts)
t.av1 <- mean(r.sum1) #calculating mean weight of the edge
sd1 <- sd(r.sum1) #calculating st.dev. of the edge weight
tres1 <- round(t.av1 + sd1, 0) 
cp1 <- coocc.data < tres1 #if smaller than cutting point, then replaced by 0
coocc.data[cp1==TRUE] <- 0

# actor by actor matrix 
r.sum2 <- rowMeans(over.data, na.rm = FALSE, dims = 1) 
t.av2 <- mean(r.sum2)
sd2 <- sd(r.sum2)
tres2 <- t.av2 # -sd2 
cp2 <- over.data < tres2 
over.data[cp2==TRUE] <- 0

val.coocc.data <- as.sociomatrix(coocc.data, "value") #saving edge weights
val.over.data <- as.sociomatrix(over.data, "value") 

plot.sociomatrix(coocc.data) #shows as a valued sociomatrix
plot.sociomatrix(over.data) 
plot.sociomatrix(ccm.coocc.data)

# converting to network objects

co.net <- network(coocc.data, valued = T, bipartite = F, directed = F) #code network
ov.net <- network(over.data, valued = T, bipartite = F, directed = F) #actor network

# saving one-mode projections

setwd("...data/live_data/live_1/analysis_data/network/whole")
write.csv(coocc.data, file=paste("n_47_live_1_code_net.csv", sep=""), row.names=F)

#setwd("...data/live_data/live_1/analysis_data/network/whole")
#write.csv(over.data, file=paste("n_47_live_1_actors_net.csv", sep=""), row.names=F)

# adding attribute data to vertices

setwd("...data/live_data/live_1")
att.data <- read.csv("n_47_live_1_opinion.csv")

# opinon towards the repository

opinion <- as.character(att.data[,4])
opinion1 <- opinion
opinion2 <- c(opinion, rep(NA, length(cam[1,])))

# bipartite network
cam.net%v%'color' <- opinion2 #adds attribute to bipartite network
cam.net%v%'color' <- gsub("disagree", "orangered1", cam.net%v%'color')
cam.net%v%'color' <- gsub("neutral", "grey", cam.net%v%'color')
cam.net%v%'color' <- gsub("agree", "lightgreen", cam.net%v%'color')
cam.net%v%'color' <- gsub("nonavailable", "yellow2", cam.net%v%'color')
cam.net%v%'color'

# actor network
ov.net%v%'color' <- opinion1 #adds attribute to bipartite network
ov.net%v%'color' <- gsub("disagree", "orangered1", ov.net%v%'color')
ov.net%v%'color' <- gsub("neutral", "grey", ov.net%v%'color')
ov.net%v%'color' <- gsub("agree", "lightgreen", ov.net%v%'color')
ov.net%v%'color' <- gsub("nonavailable", "yellow2", ov.net%v%'color')
ov.net%v%'color'

# positions of the actors

position <- as.character(att.data[,2])
position

# bipartite network
cam.net%v%'color' <- position
cam.net%v%'color' <- gsub("mayor", "yellow", cam.net%v%'color')
cam.net%v%'color' <- gsub("working_group", "yellow", cam.net%v%'color')
cam.net%v%'color' <- gsub("NGO", "lightblue", cam.net%v%'color')
cam.net%v%'color' <- gsub("state_official", "grey", cam.net%v%'color')
cam.net%v%'color'

# actor network
ov.net%v%'color' <- position
ov.net%v%'color' <- gsub("mayor", "yellow", ov.net%v%'color')
ov.net%v%'color' <- gsub("working_group", "lightgreen", ov.net%v%'color')
ov.net%v%'color' <- gsub("NGO", "orangered1", ov.net%v%'color')
ov.net%v%'color' <- gsub("state_official", "grey", ov.net%v%'color')
ov.net%v%'color'

# localities

locality <- as.character(att.data[,3])
locality

# bipartite network
cam.net%v%'color' <- locality2
cam.net%v%'color' <- gsub("HR", "yellow", cam.net%v%'color')
cam.net%v%'color' <- gsub("HO", "grey", cam.net%v%'color')
cam.net%v%'color' <- gsub("CI", "pink", cam.net%v%'color')
cam.net%v%'color' <- gsub("KH", "lightgreen", cam.net%v%'color')
cam.net%v%'color' <- gsub("BP", "orangered1", cam.net%v%'color')
cam.net%v%'color' <- gsub("MA", "brown", cam.net%v%'color')
cam.net%v%'color' <- gsub("CE", "purple", cam.net%v%'color')
cam.net%v%'color' <- gsub("nd", "white", cam.net%v%'color')
cam.net%v%'color'

# actor network
ov.net%v%'color' <- locality2
ov.net%v%'color' <- gsub("HR", "yellow", ov.net%v%'color')
ov.net%v%'color' <- gsub("HO", "grey", ov.net%v%'color')
ov.net%v%'color' <- gsub("CI", "pink", ov.net%v%'color')
ov.net%v%'color' <- gsub("KH", "lightgreen", ov.net%v%'color')
ov.net%v%'color' <- gsub("BP", "orangered1", ov.net%v%'color')
ov.net%v%'color' <- gsub("MA", "brown", ov.net%v%'color')
ov.net%v%'color' <- gsub("CE", "purple", ov.net%v%'color')
ov.net%v%'color' <- gsub("nd", "white", ov.net%v%'color')
ov.net%v%'color'

#----------plotting----------

slength <- length
i <- sapply(slength, is.factor) #identifying factor columns
slength[i] <- lapply(slength[i], as.character)
slength <- slength[order(slength[,1]),]
total.length <- sum(slength[,2])
prop <- (slength[,2]/total.length)*100
slength <- cbind(slength, prop)

red.names <- as.data.frame(network.vertex.names(names1))
colnames(red.names) <- "data.codename"
red.length <- merge(slength, red.names, by.x="data.codename", by.y="data.codename")
red.prop <- (red.length[,2]/total.length)*100
red.length <- cbind(red.length, red.prop)

isol <- isolates(co.net)
names1 <- network(co.net[-isol,-isol])

# exctracting reduced networks (edge subgraphs with strong edges)

# removes weakly connected vertices (codes)
adeg <- degree(co.net[-isol,-isol], gmode="graph")
tres <- round(mean(adeg)-2*(sd(adeg)), 0) #exclusion of vertices with degree lower than 2 std. dev. below mean
tab <- as.matrix(co.net[-isol, -isol])
names <- row.names(tab)
degree <- data.frame(names, adeg)
cp3 <- degree[,2] < tres
degree <- data.frame(degree, cp3)
degree <- degree[which(degree$cp3 == FALSE),]

mcol <- match(degree[,1],colnames(cam)) #matches included codes with complete incidence matrix
cam.strip <-  cam[,mcol]
cam.strip <- as.matrix(cam.strip)

net.strip <- network(cam.strip, bipartite = T) #reduced bipartite network (47 actors and 28 codes)

# reduced code network
co.strip.data <- as.one.mode(cam.strip, project="higher", weighted=TRUE) #reduced codes cooccurence matrix 

r.sum1.strip <- rowMeans(co.strip.data, na.rm = FALSE, dims = 1) #saving row means (i.e. average edge weights for respective concepts)
t.av1.strip <- mean(r.sum1.strip) #calculating mean weight of the edge
sd1.strip <- sd(r.sum1.strip) #calculating st.dev. of the edge weight
tres1.strip <- round(t.av1.strip + sd1.strip, 0)

cp1.strip <- co.strip.data < tres1.strip #if smaller than cutting point, then replaced by 0
co.strip.data[cp1.strip==TRUE] <- 0

co.strip <- network(co.strip.data, directed=F)

setwd("...data/live_data/live_1/analysis_data/network/whole/reduced")
write.csv(co.strip.data, file=paste("n_47_live_1_codes_net_reduced.csv", sep=""), row.names=F)

isol1 <- isolates(co.strip)

# plotting code network

positions.codes <- gplot(co.net[-isol, -isol], gmode="graph", mode="kamadakawai")
par(mfrow=c(1,2))
gplot(co.net[-isol, -isol], gmode="graph", mode="kamadakawai", usearrows=F, coord=positions.codes, 
      , label=network.vertex.names(as.network(co.net[-isol, -isol])), label.pos=5, vertex.col="lightblue", edge.col="lightgrey"
      , edge.lwd=coocc.data
      , vertex.cex=(red.length[,2]/10000)
)
gplot(co.strip, gmode="graph", mode="kamadakawai", usearrows=F, coord=positions.codes,  
      , label=network.vertex.names(as.network(co.strip)), label.pos=5, vertex.col="lightblue", edge.col="lightgrey"
      , edge.lwd=coocc.data
      , vertex.cex=(red.length[,2]/10000
))
par(mfrow=c(1,1))

# reduced actor network (only strength of the edges, low degree actors are not excluded)

ov.strip.data <- as.one.mode(cam, project="lower", weighted=TRUE) #actors overlap matrix
r.sum2.strip <- rowMeans(ov.strip.data, na.rm = FALSE, dims = 1) #saving row means (i.e. average edge weights for respective concepts)
t.av2.strip <- mean(r.sum2.strip) #calculating mean weight of the edge
sd2.strip <- sd(r.sum2.strip) #calculating st.dev. of the edge weight
tres2.strip <- round(t.av2.strip + sd2.strip, 0) #only edges with value over 2 std. dev. above the mean
cp2.strip <- ov.strip.data < tres2.strip #if smaller than cutting point, then replaced by 0
ov.strip.data[cp2.strip==TRUE] <- 0

ov.strip <- network(ov.strip.data, bipartite=F, directed=F)
ov.strip.deg <- degree(ov.strip, gmode="graph")

positions.actors <- gplot(ov.net, gmode="graph", mode="kamadakawai")
par(mfrow=c(1,2))
gplot(ov.net, gmode="graph", mode="kamadakawai", usearrows=F, coord=positions.actors,  
      , label=network.vertex.names(network(ov.net)), label.pos=5, vertex.sides=5, edge.col="lightgrey"
      , edge.lwd=over.data
      , vertex.col=ov.net%v%'color'
      , vertex.cex=((degree(over.data, gmode="graph", ignore.eval=F))/100)
)
gplot(ov.strip, gmode="graph", mode="kamadakawai", usearrows=F, coord=positions.actors,  
      , label=network.vertex.names(network(ov.strip)), label.pos=5, vertex.sides=5, edge.col="lightgrey"
      #, edge.lwd=ov.strip.data
      , vertex.col=ov.net%v%'color'
      , vertex.cex=((degree(ov.strip.data, gmode="graph", ignore.eval=F))/100)
)
par(mfrow=c(1,1))



